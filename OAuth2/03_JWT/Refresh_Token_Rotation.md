# Refresh Token Rotation

**Refresh Token Rotation(리프레시 토큰 로테이션)**은 보안을 강화하기 위해 **Refresh Token을 일회용으로 사용하는 전략**입니다.

클라이언트가 Access Token을 재발급받기 위해 Refresh Token을 사용할 때마다, **새로운 Access Token과 함께 '새로운 Refresh Token'도 발급**하고, 기존 Refresh Token은 폐기(무효화)하는 방식입니다.

핵심 원리와 장점은 다음과 같습니다.

## 1. 동작 과정 (Flow)

일반적인 방식은 Refresh Token을 유효기간 동안 계속 쓰지만, 로테이션 방식은 아래와 같이 동작합니다.

1. **클라이언트 요청:** `Refresh Token A`를 서버로 보냅니다.
2. **서버 검증:** `Refresh Token A`가 유효한지 확인합니다.
3. **토큰 교체 (Rotation):**
* 서버는 `Refresh Token A`를 **사용됨(Used)** 상태로 변경하거나 삭제합니다.
* 새로운 `Access Token`과 **새로운 `Refresh Token B`**를 생성하여 발급합니다.


4. **클라이언트 저장:** 클라이언트는 이제 `Refresh Token B`를 저장하고, 다음 요청 때 이것을 사용합니다.

## 2. 왜 사용하는가? (핵심: 보안)

가장 큰 이유는 **탈취된 Refresh Token의 재사용 감지(Reuse Detection)** 때문입니다.

* **상황:** 해커가 사용자의 `Refresh Token A`를 훔쳤다고 가정해 봅시다.
* **방어:**
1. 사용자가 정상적으로 `Refresh Token A`를 사용해 `Refresh Token B`를 발급받습니다. (이때 A는 무효화됨)
2. 나중에 해커가 훔친 `Refresh Token A`로 접근을 시도합니다.
3. 서버는 **"어? 이미 사용된(무효화된) A가 또 들어왔네?"** 라고 감지합니다.
4. 서버는 이를 **토큰 탈취 시도**로 간주하고, `Refresh Token A`에서 파생된 모든 토큰 패밀리(B, C...)를 **전부 강제 만료**시켜 버립니다.
5. 결과적으로 사용자는 다시 로그인을 해야 하지만, 해커도 더 이상 접근할 수 없게 됩니다.



## 3. 고려할 점

* **구현 복잡도:** 단순히 조회만 하는 것이 아니라, 매번 발급하고 기존 토큰을 무효화하는 로직이 추가되어야 합니다.
* **동시성 문제 (Race Condition):** 프론트엔드에서 실수로 짧은 시간에 여러 번 토큰 재발급 요청을 동시에 보내면, 먼저 도착한 요청이 토큰을 바꿔버려서 뒤으 요청이 실패할 수 있습니다. (약간의 유예 기간을 두는 방식으로 해결하기도 합니다.)

## 요약

한 번 쓴 Refresh Token은 버리고 새것으로 갈아타서, 혹시 모를 탈취 사고 시 피해를 최소화하는 기법입니다.